(* Specification of two's complement machine words wrt Z *)

Require Import Coq.ZArith.BinIntDef Coq.ZArith.BinInt Coq.ZArith.Zdigits.
Local Open Scope Z_scope.

Module word.
  Class word {width : Z} := {
                             rep : Type;

                             (* defining relations *)
                             unsigned : rep -> Z;
                             signed : rep -> Z;
                             of_Z : Z -> rep;
                             of_bool : bool -> rep;
                             max_word : rep;
                             min_word : rep;

                             (* operations *)
                             add : rep -> rep -> rep;
                             sub : rep -> rep -> rep;
                             opp : rep -> rep;

                             or : rep -> rep -> rep;
                             and : rep -> rep -> rep;
                             xor : rep -> rep -> rep;
                             not : rep -> rep;
                             ndn : rep -> rep -> rep;
                             uand : rep -> rep;
                             uor : rep -> rep;
                             uxor : rep -> rep;

                             mul : rep -> rep -> rep;
                             mulhss : rep -> rep -> rep;
                             mulhsu : rep -> rep -> rep;
                             mulhuu : rep -> rep -> rep;

                             divu : rep -> rep -> rep;
                             divs : rep -> rep -> rep; (* Z.quot *)
                             modu : rep -> rep -> rep;
                             mods : rep -> rep -> rep; (* Z.rem *)

                             slu : rep -> rep -> rep;
                             sru : rep -> rep -> rep;
                             srs : rep -> rep -> rep;

                             eqb : rep -> rep -> bool;
                             ltu : rep -> rep -> bool;
                             lts : rep -> rep -> bool;

                             gtu x y := ltu y x;
                             gts x y := lts y x;

                             swrap z := (z + 2^(width-1)) mod 2^width - 2^(width-1);

                             sextend: Z -> rep -> rep; (* Z is bitwidth of input *)
                           }.


  Arguments word : clear implicits.
  

  Class ok {width} {word : word width}: Prop := {
                                                 wrap z := z mod 2^width;

                                                 width_pos: 0 < width;

                                                 unsigned_of_Z : forall z, unsigned (of_Z z) = wrap z;
                                                 signed_of_Z : forall z, signed (of_Z z) = swrap z;
                                                 of_Z_unsigned : forall x, of_Z (unsigned x) = x;
                                                 of_bool_unsigned : forall x, unsigned (of_bool x) = wrap (ZArith.Zdigits.bit_value x);
                                                 max_word_unsigned : unsigned max_word = (wrap (-1)%Z);
                                                 min_word_unsigned : unsigned min_word = (wrap 0%Z);

                                                 unsigned_add : forall x y, unsigned (add x y) = wrap (Z.add (unsigned x) (unsigned y));
                                                 unsigned_sub : forall x y, unsigned (sub x y) = wrap (Z.sub (unsigned x) (unsigned y));
                                                 unsigned_opp : forall x, unsigned (opp x) = wrap (Z.opp (unsigned x));

                                                 unsigned_or : forall x y, unsigned (or x y) = wrap (Z.lor (unsigned x) (unsigned y));
                                                 unsigned_and : forall x y, unsigned (and x y) = wrap (Z.land (unsigned x) (unsigned y));
                                                 unsigned_xor : forall x y, unsigned (xor x y) = wrap (Z.lxor (unsigned x) (unsigned y));
                                                 unsigned_not : forall x, unsigned (not x) = wrap (Z.lnot (unsigned x));
                                                 unsigned_ndn : forall x y, unsigned (ndn x y) = wrap (Z.ldiff (unsigned x) (unsigned y));
                                                 unsigned_uand : forall x, unsigned (uand x) = wrap (ZArith.Zdigits.bit_value (Z.eqb ((wrap (-1)%Z)) (unsigned x)));
                                                 unsigned_uor : forall x, unsigned (uor x) =  wrap (ZArith.Zdigits.bit_value (negb (Z.eqb ((wrap 0)) (unsigned x))));
                                                 

                                                 unsigned_mul : forall x y, unsigned (mul x y) = wrap (Z.mul (unsigned x) (unsigned y));
                                                 signed_mulhss : forall x y, signed (mulhss x y) = swrap (Z.mul (signed x) (signed y) / 2^width);
                                                 signed_mulhsu : forall x y, signed (mulhsu x y) = swrap (Z.mul (signed x) (unsigned y) / 2^width);
                                                 unsigned_mulhuu : forall x y, unsigned (mulhuu x y) = wrap (Z.mul (unsigned x) (unsigned y) / 2^width);

                                                 unsigned_divu : forall x y, unsigned y <> 0 -> unsigned (divu x y) = wrap (Z.div (unsigned x) (unsigned y));
                                                 signed_divs : forall x y, signed y <> 0 -> signed x <> -2^(width-1) \/ signed y <> -1 -> signed (divs x y) = swrap (Z.quot (signed x) (signed y));
                                                 unsigned_modu : forall x y, unsigned y <> 0 -> unsigned (modu x y) = wrap (Z.modulo (unsigned x) (unsigned y));
                                                 signed_mods : forall x y, signed y <> 0 -> signed (mods x y) = swrap (Z.rem (signed x) (signed y));

                                                 unsigned_slu : forall x y, Z.lt (unsigned y) width -> unsigned (slu x y) = wrap (Z.shiftl (unsigned x) (unsigned y));
                                                 unsigned_sru : forall x y, Z.lt (unsigned y) width -> unsigned (sru x y) = wrap (Z.shiftr (unsigned x) (unsigned y));
                                                 signed_srs : forall x y, Z.lt (unsigned y) width -> signed (srs x y) = swrap (Z.shiftr (signed x) (unsigned y));

                                                 unsigned_eqb : forall x y, eqb x y = Z.eqb (unsigned x) (unsigned y);
                                                 unsigned_ltu : forall x y, ltu x y = Z.ltb (unsigned x) (unsigned y);
                                                 signed_lts : forall x y, lts x y = Z.ltb (signed x) (signed y);
                                               }.


  Arguments ok {_} _.

  
End word.

Notation word := word.word.

Global Coercion word.rep : word >-> Sortclass.


